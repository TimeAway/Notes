## 几种常见的排序算法

常见的10大排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。

### 1. 冒泡排序法

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。

**算法描述**

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

![冒泡排序法](./images/BubbleSort.gif)

**算法实现**

```javascript
const bubbleSort = (arr) => {
  let tem;

  for (let i = 0; i < arr.length; i++) {
    for (let j = i; j < arr.length - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        tem = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tem;
      }
    }
  }
  return arr;
}
```

**稳定性**

在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。

**适用场景**

冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。

**时间复杂度**

O( n2 )

**代码优化**

增加一个 `swap` 的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。

最佳情况下时间复杂度可达：**O(n)**

```javascript
const bubbleSort = (arr) => {
  let tem, swap;

  for (let i = 0; i < arr.length; i++) {
    swap = false;
    for (let j = i; j < arr.length - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        tem = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tem;
        swap = true;
      }
    }

    if (!swap) {
      return arr;
    }
  }
  return arr;
}
```



### 2. 选择排序法

选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。

**算法描述**

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

![选择排序法](./images/selection-sort.gif)

**算法实现**

```javascript
const selectionSort = (arr) => {
  let min, tem;
  for (let i = 0; i < arr.length - 1; i++) {
    min = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    }

    if (min !== i) {
      tem = arr[i];
      arr[i] = arr[min];
      arr[min] = tem;
    }
  }
  return arr;
}
```

**稳定性**

用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。

**适用场景**

选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。

**时间复杂度**

O( n2 )
