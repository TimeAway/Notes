## 1. HTTP 与 HTTPS

### 1.1 什么是 HTTP？

**HTTP** 全称 **Hyper Text Transfer Protocol**，译为**超文本传输协议**。其主要用于客户端与服务端之前的通信。协议规定，请求从客户端发出，最后服务器端响应该请求并返回。

**HTTP** 是一种**无状态协议**，即协议自身不对请求和响应之间的通信状态进行保存，也就是说在 HTTP 中，协议对于发送过的请求和响应都不做持久化处理。这样可以更快地处理大量事务，确保协议的可伸缩性。

### 1.2 HTTP 的缺点

- 通信使用明文（不加密），内容可能会被窃听

- 不验证通信方的身份，因此有可能遭遇伪装

- 无法证明报文的完整性，所以有可能已遭篡改

![http](https://res.weread.qq.com/wrepub/epub_907764_161)

### 1.3 什么是 HTTPS？

**HTTPS** = HTTP + 加密+ 认证 + 完整性保护

在 HTTP 上再加入加密处理和认证等机制，添加了加密及认证机制的 HTTP 称为 **HTTPS**（HTTP Secure）。

**HTTPS** 并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替而已。

![https](https://res.weread.qq.com/wrepub/epub_907764_172)

从上图可以看出，在 HTTPS 通信中，HTTP 与 TCP 的直接通信转变为先和 SSL 进行通信，再由 SSL 与 TCP 进行通信。



## 2. Position 的值，relative 和 absolute 分别相对于谁定位的？

CSS Position 用于指定一个元素在文档中的定位方式。[`top`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/top)，[`right`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/right)，[`bottom`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom) 和 [`left`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/left) 属性则决定了该元素的最终位置。

Position 定位类型分为以下几种：

**relative 相对定位**

相对定位是相对于元素本身进行定位，元素位置的调整不改变页面的布局，因此未添加定位时所在位置会留下空白。

*注意：position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。*

**absolute 绝对定位**

绝对定位是相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。元素会被移出正常文档流，并不为元素预留空间。

绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。

**fixed 固定定位**

固定定位是相对于屏幕视口（viewport）的位置来指定元素位置。元素会被移出正常文档流，并不为元素预留空间。

元素的位置在屏幕滚动时不会改变。

*注意：当元素祖先的 `transform`, `perspective` 或 `filter` 属性非 `none` 时，容器由视口改为该祖先。*

**sticky 粘性定位**

sticky 元素根据正常文档流进行定位。偏移值不会影响任何其他元素的位置。

sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上(`overflow` 是 `hidden`, `scroll`, `auto`, 或 `overlay`时)



## 3. 如何解决跨域问题？

**跨域**：当前发起请求的域与该请求指向的资源所在的域不一样。协议 + 域名 + 端口号均相同，那么就是同域（**同源策略**），否则即为跨域。

**同源策略限制以下几种行为**：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获得
- AJAX 请求不能发送



**跨域解决方案**

1. **JSONP**

   JSONP 是一种非官方的跨域数据交互协议，其本质上是利用 `<script><img><iframe>` 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输。

   JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的 JSON 数 据。

   JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段  Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。

如下代码：

```html
// 页面中声明有这样的一个函数，它将作为 JSONP 的回调函数处理作为函数参数传入的数据
<script type="text/javascript">
  function dosomething(jsondata){
		//处理获得的json数据
	}
</script>

// 告知服务端回调函数的函数名
<script src="http://example.com/data.php?callback=dosomething"></script>

// 服务端在返回数据的时候，就会返回一端 Javascript 代码，在 Javascript代码中调用了回调函数，并且需要返回的数据作为回调函数的参数
dosomething(['a','b','c']);
```

**注意**：只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。

2. **CORS**

跨源资源共享 **Cross-Origin Resource Sharing(CORS)** 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求。

原理是浏览器首先使用 OPTION 方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求，在服务器确定允许后，才发起实际的 HTTP 请求。

**CORS 新增的 HTTP 首部字段**

```
// 响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源
Access-Control-Allow-Origin: <origin> | *

// 预检请求的响应，指明实际请求所允许使用的HTTP方法
Access-Control-Allow-Methods: <method>[, <method>]*

// 用于预检请求的响应。指明了实际请求中允许携带的首部字段
Access-Control-Allow-Headers: <field-name>[, <field-name>]*

// 用于预检请求的响应，指定了预检请求能够被缓存多久
Access-Control-Max-Age: <delta-seconds>

// 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。
Access-Control-Allow-Credentials: true

// 表明预检请求或实际请求的源站。不管是否为跨域请求，Origin字段总是被发送。
Origin
```

**注意**：浏览器IE10以下不支持。

3. **Nginx 代理跨域**

Nginx代理跨域，实质和 CORS 跨域原理一样，通过配置文件设置请求响应头 Access-Control-Allow-Origin…等字段。

**nginx配置解决iconfont跨域**

浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置：

```nginx
location / {
 add_header Access-Control-Allow-Origin *;
}
```

**nginx 反向代理接口跨域**

跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。

实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。

nginx具体配置：

```nginx
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

4. **Node 中间件代理跨域**

node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

5. **postMessage 跨域**

postMessage 是 HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**注意**：HTML5 新特性，兼容性不是很好，只适用于主流浏览器和IE10+。

6. **WebSocket 协议跨域**

原理：这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

```javascript
let socket = new WebSocket("ws://localhost:8080");

socket.onopen = function() {
    socket.send("holle");
};

socket.onmessage = function(e) {
    console.log(e.data);
};
```

**注意**：HTML5 新特性，兼容性不是很好，只适用于主流浏览器和IE10+。

7. **浏览器开启跨域**

其实跨域问题是浏览器策略，关闭这个功能即可。

**Windows** 

找到安装的目录

\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx

**Mac**

~/Downloads/chrome-data这个目录可以自定义.

/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary --disable-web-security --user-data-dir=~/Downloads/chrome-data



## 4. Heap 排序方法的原理?复杂度?
